# Cross Site Scripting (XSS)

# Samy Wrom
## 概要
* ソーシャルメディアMySpaceで流行したワーム
* ある利用者が、Samy Kamkar氏のMySpace上のページを閲覧した際、同氏の友達リストにいなければ、自動的に友達リクエストを送信するスクリプトをMySpace上に仕組んだ。
  * Samyのページを閲覧しSamy wormに感染する。
  * Samy wormは感染者のページにもSamy wormのスクリプトを置き、感染者のページの訪問者がSamyに友達申請するようにした。

具体的なsamy wormの活動については、[Samy氏のサイト](https://samy.pl/myspace))や[XSSワーム「Samy」の動作を解析する](https://akaki.io/2018/analyzing_samy_xss_worm) に詳しい解説がある。
```
アメリカのハッカーであるSamy Kamkar氏（@samykamkar）が2005年にリリースしたMySpaceを標的とするXSSワームが「Samy（JS.Spacehero）」である。当時のソーシャル・ネットワーキング・サービスMySpaceは、プロフィールをユーザー好みのスタイルに設定できる仕様であり、一部のHTMLタグの使用が許可されていた。JavaScriptの実行につながるタグや属性などの使用は禁止されていたが、Kamkar氏はそのフィルター処理を回避できた¹。当時19歳だったKamkar氏はこの抜け道を利用して友達を増やすためにSamyを開発した。

2005年10月4日にKamkar氏のプロフィールで公開されたSamyは、わずか20時間で100万人以上のMySpaceユーザーに感染した。このワームは最も急速に感染を広げたマルウェアと考えられており、XSSワームの起源にして頂点といえる。感染したユーザーはKamkar氏のアカウントへのフレンド申請を強制され、プロフィールのヒーロー欄に but most of all, samy is my hero. との文言とペイロード（Samy自身）を書き込まれる。情報資産の窃取や金銭の要求などの悪質な行為は行なわれなかった。
```
## 感染拡大のタイムライン
* 10/04 12:34 Samyは73人の友人をMySpace上に有していた
  * 友人間で有名になることを目指してsamy wormを投下した。
* 1時間後、10/04 1:30 am 73人の友人と、1件の友達申請があった。
* 7時間後、10/04 8:35 am 74人の友人と、221件の友達申請があった。
  * 200名以上が8時間でwormに感染した。すると毎日600人の新しい友達ができることになる。
* さらにその1時間後、74人の友人と480件の友達申請（指数的に増大）があった。
* 10/04 10:30 am 518人の友人と561件の友達申請があった。
  * 併せて「怒り」のメッセージやメールが届いた
* 3時間後の13:30に2,503人の友人と6,373件の友達申請があった。
  * Samyはアカウントを解約しようとした。既にそのとき、Samy wormは制御不能だった。
* 5時間後の6:20 pmにSamyが確認すると、2,503人の友人と917,084件の友達申請があった。
  * 3秒後に918,268、その3秒後に919,664、その後1,005,831。
* 正式にSamyは有名人になった。
* その後、7:05 pm に、Myspaceにアクセスできなくなり、メンテナンスのために停止したと噂が広まる。
  * SamyはMyspaceのオフィスに行って、謝るべきか悩んだ。
* その2時間半後の9:30pmに、Myspaceの稼働を確認した。その際自己増殖するプログラムはサイト全体から消えていた。
  * Ferossは、正規表現ですべてのデータからスクリプトを削除したと推定している。

# 同一オリジンポリシーはオリジンを跨がったDOM操作を許さない
* attacker.com は次のような挙動ができない。
```
<iframe src='https://bank.com'></iframe>
<script>
    window.frames[0].forms[0].addEventListener('submit', () =>{
    // usernameやpasswordを奪う！
    })
</script>
```
攻撃者はJavaScriptをどうにかして走らせようとする。

# XSSはコードインジェクションの脆弱性
* コードインジェクションとは、意図しない信頼性の低いデータがコードになってしまうことである。
* ユーザーのデータに関連するコマンドは弱い。
* HTMLドキュメントのなかに意図せずJavaScriptのコードを埋め込んでしまうことがXSSになる。
* SQLインジェクションは、クエリが意図しないコードとして動作する。
  
# XSSが成功すると、ブラウザを通じて標的のコンピュータを操作できる。
* Cookiesの閲覧、抜き出し
* 標的のCookiesを利用したHTTPリクエストの送信

# 無害な検索クエリ
* ユーザの入力: flower
* URL: example.com/?search=flower
* サーバへの入力: flower
* 検索結果
  ```
  <p>Search result for flower</p>
  ```

# 悪質な検索
* ユーザの入力: <script>alert(document.cookie)</script>
* URL: example.com/?search=%3Cscript%3Ealert(document.cookie)%3C/script%3E
* サーバへの入力: <script>alert(document.cookie)</script>
* 検索結果
  ```
  <p>Search result for <script>alert(document.cookie)</script></p>
  ```

## DEMO
* リンク元のWebページの内容を元に、メッセージを変える
  * `const source = req.query.source` を追記して、URLのクエリから`source`を設定する
* URLに`?source=<script>alert(document.cookie)</script>`を追記するとJavaScriptが実行されることを確認する

## DEMO FIX
* htmlEscapeを入れることで`<` が `&lt;` になることを確認する.
  * `const htmlEscape = require('html-escape')`
  * `htmlEscape()`によって、`req.query.source`を無害化する。`const source = htmlEscape(req.query.source)`
  * [WhiteHat](https://www.synopsys.com/blogs/software-security/top-10-software-vulnerability-list-2019/), [OWASP Top 10](https://owasp.org/www-project-top-ten/)

# 基本的な考え方: クライアントを信用しない
* クライアントが制御するいかなるデータも怪しいとみるべき
* クライアントは思い通りにサーバにデータを送ることが出来る
  * そのためデータをチェックしないといけない

# 何がXSSの影響を幅広くしているのか
* データを多様で異なる目的・用途で利用する
  * Webで利用できる言語はたくさんある。
  * HTMLであっても少なくとも5つのスクリプトを記述し実行できる箇所（コンテキスト）を理解する必要がある。
* それぞれが異なる制御文字列を利用する。
  * さらに、複雑なルールもある。
* これらのうち1箇所でも躓けば、脆弱なシステムとなる

# Refrected vs Stored XSS
* Refected XSS (反射型XSS)
  * 攻撃者はHTTPリクエストを利用してXSSを仕掛けるために、攻撃用のJavascriptを別サイトに置く。
    * 例えば、標的がよく利用するWebサイトやそれらを偽装したサイトを利用してXSSを仕掛ける。
    * メールのURLに攻撃用のスクリプトを置くこともできる。
    * 入力値をそのまま表示するサイトに仕掛ける。たとえば、クライアントの入力値を確認する画面を表示するページなどにある。
  * 攻撃者の目標：標的が攻撃者の設置したコードを実行するためのURLを踏むよう誘導する
  * 攻撃条件：標的がURLやクエリのパラメータとして攻撃コードを入力する
* Stored XSS (Persistent XSS, 持続型XSS)
  * 攻撃用のコードをデータベースなどに保存する。
    * Webメールやソーシャルメディアに攻撃用スクリプトを保存する。例：Samy
  * 攻撃者の目標：攻撃者は様々な手法を利用してデータベースに攻撃コードを埋め込む。

# HTMLの要素
## 例： HTML要素はタグによって囲まれている
```
<p><b>ゼルダの伝説シリーズ</b>（ゼルダのでんせつシリーズ、<a href="/wiki/%E8%8B%B1%E8%AA%9E" title="英語">英</a>&#58; <span lang="en">The Legend of Zelda series</span>）は<a href="/wiki/%E4%BB%BB%E5%A4%A9%E5%A0%82" title="任天堂">任天堂</a>が開発・発売している<a href="/wiki/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%82%B2%E3%83%BC%E3%83%A0" title="コンピュータゲーム">コンピュータゲーム</a>シリーズ<sup id="cite_ref-nn-1_7-0" class="reference"><a href="#cite_note-nn-1-7">&#91;6&#93;</a></sup>。
```

## HTMLタグが利用者からの入力を囲む
* HTMLのテンプレート
  * 利用者からの入力をタグで囲んで表示する
  * 不正なコードを混入させないために、入力値を変換する必要がある
```
<p>USER_DATA_HERE</p>
```
* 修正案は？ 
  * 入力値の`<` を `&lt;`に変換する。
    * `<` はタグの始まりに出てくる。これを無害化する。
  * 入力値の`&` を `&amp;` に変換する。
    * `&`は一部のコードの記法がよく利用する。
  * `<style>` や `<script>` は、CSSやJavaScriptであり、それぞれ記法が違う！

* 修正案を施してJavaScriptがUSER_DATA_HEREに入る場合
  * ユーザからの入力値：`<script>alert(document.cookike)</script>`
  * 出力結果：`&lt;script>alert(document.cookike)&lt;/script>`
    * JavaScriptは実行できない！

## HTML Attribute
* HTMLタグのAttribute(属性)部分にもコードが入り込む場合がある。
* 例： 入力値によって属性を変化させる場合
```
<img src='avatar.png' alt='Dai Mochianga' />
```
  これをユーザからの入力値を反映するようなコードに書き換える。
```
  <img src='avatar.png' alt='USER_DATA_HERE' />
```
ここで、悪意のあるユーザーからの入力とその結果は次の通り。
* 入力における留意点
  * `'`を入力にいれ、onloadにJavaScriptを仕込む
  * onload 属性は、画像の読み込みイベント後にスクリプトを実行する
```
Input: Dai' onload='alert(document.cookike)
Result:
<img src='avatar.png' alt='Dai' onload='alert(document.cookie)' />
```
* 修正案は？
  * `'`を`&apos;`に変換する
  * `"`を`&quot;`に変換する
* 修正案を適用後
  * `'` が `&apos;`になって、無害化した。
```
  <img src='avatar.png' alt='USER_DATA_HERE' />

Input: Dai' onload='alert(document.cookike)
Result:
<img src='avatar.png' alt='Dai&apos; onload=&apos;alert(document.cookie)' />
```

## HTML Attribute without quotes
* `'`のないAttribute属性の場合
```
<img src=avatar.png alt=Dai />
```
* 入力に`'`を入れなくとも悪用できる。
```
Input: Dai onload=alert(document.cookike)
Result:
<img src='avatar.png' alt='Dai' onload='alert(document.cookie)' />
```
* 修正案は？
  * 常に属性はquoteをつける。
  * quoteがない属性は、さまざまな文字で悪用できる。
    * 空白、`%`, `*`, `+`, `,`, `-`, `/`, `;`, `<`, `=`, `>`, `^`, `|`など 

## 特別な意味を持つHTML属性に注意する
* 多くのAttributeは特定の文字をエスケープすることで対策できる。
* 特別な意味をもつ`src`や`href`は注意する。
  * e.g. `<script src='USER_DATA_HERE'></script>` は危険である。たとえ、属性をフィルタリングしても危険である。
  * URLのうち、プロトコル`data:`や`javascritpt:`は注意する。

### DEMO
* Webブラウザに次の文字列を打ち込んでみる
  * `data:` 小さなファイルをインラインで文書に埋め込む 参考：[データURL](https://developer.mozilla.org/ja/docs/Web/HTTP/Basics_of_HTTP/Data_URLs)
    * `data:text/html,<h1>Hi</h1>`
    * `data:text/html,><script>alert('Hi')</script>`
    * `data:text/html,<html contenteditable></html>`
  * `javascript:`ブラウザのアドレスバーからJavaScriptのコードを実行する
    * javascript疑似プロトコルと呼ばれる。
    * 有効なURIスキームではない。そのため、IANAは「javascript:」をURIとして管理していません。
    * `http://example.com`のページ上で`javascript:alert('Hi')`を実行すると、WebサイトのJavaScriptを実行しているようにみえる。
      * `javascript:alert('Hi')`をコピーして、アドレスバーにペーストする.
      * すると`javascript:`は消える。
      * これは他のプログラムからアドレスバーへのペーストにおいて、フィッシング等の被害を防ぐために、フィルタリング処理をしているからである。
    * Safariからは実行できない

### data: や javascript: は何のためにあるのか。
* これまで使われていた、クリックを促す方法である。
* HTTPリクエストをHTTPページの中に埋め込む方法
  * 一般的な `<img>` の場合は、HTTPページを読み込んでから画像を読み込む。しかし、エンコードしてデータにして埋め込めば、HTTPの読み込みと同時に読み込める。
  * Webサイトのロゴなど、最初に表示して欲しいものを埋め込むのに使う。
  ```
  <img src='data:image/png;base64,iVBORwoOKDIAIDIJASO...' />
  ```
* CSSファイルにHTTPリクエストを埋め込む
  ```
  body {
    background-image:url(data:image/png;base64,iVBORwoOKDIAIDIJASO...);
    }
  ```