# Same origin policy exceptions + ambient authority
* アンビエント権限はCookiesによって実装されている
* attacker.comはtarget.comにあるアバターを埋め込むことができる。
  * 埋め込むことでフィッシングサイトを作ることが出来る。
  ```
  <h1>Welcome to your account</h1>
  <img src='https://target.com/avatar.png' />
  ```
## Solution: SameSite Cookies
* SameSite Cookie属性を利用することで、別のサイトによるリクエストに伴うCookieの設定を防ぐことが出来る。
* クライアントがtarget.com でavater.pngを参照するときと、attaker.comでavater.pngを参照するときのHTTPリクエストは次のように異なっている。
  * target.com のHTTPリクエスト
  ```
  GET /avater.png HTTP/1.1
  Cookie: sessionId=1234 // target.com からのリクエストにはCookieがつけられるけど、attacker.comからのリクエストにはCookieがつかない
  Referer: https://target.com
  ```  
  *attacker.com のHTTPリクエスト
  ```
  GET /avater.png HTTP/1.1
  Referer: https://attacker.com
  ```
## Solution: Referrer header
* Referrer HTTPヘッダーを見ることで、どのサイトがリクエストをしているかがわかる。
* "allowlist"にないオリジンを拒否することが出来る
* HTTPキャッシュに注意！　
  * ブラウザはキャッシュを使うことで、通信を効率化しようとする
  * 例えば、一度avater.pngを正規に入手したのち、Referrer: attaker.comに埋め込まれているものを読み込んだとき、クライアントはキャッシュを利用することで、avater.pngを表示する。これは、サーバー側がallowlistでチェックしても、クライアント側で完結している動作なので禁止できない。
  * 対策としては `Vary: Referer`をヘッダにつける
  * `Cache-Control: nostore` をヘッダに付ける
* サイトはReferrerヘッダを付けないこともできることに注意！
  * これは対策ができないのでSameSite Cookiesをつかう。
  * 例えばGoogle Docsで編集しているドキュメントはURLを持っている。これは秘密にしておきたいURLの場合がある。

# CookiesはSame Origin Policyに従わない
* Cookieの仕組みは Same Origin Policyよりも前に作られた。そのため、セキュリティモデルは異なる。
* CookiesはSameOrigin Policyよりも詳細に設定できる点
  * Pathは不十分である。なぜなら、同一オリジンのページが、DOM間でアクセスできるからである。
* Cookiesは、Same Orign Policyよりも詳細でない点
  * 異なるオリジンは,別のオリジンのcookieを台無しにする（例えば、attacker.stanford.edu は stanford.eduのcookieを設定できる)
  * これはscombz.shibaura-it.ac.jpがshibaura-it.ac.jpのcookieを設定できると読み替えられる。また、scombz内でcookieを限定することで安全性を確保している理由にもなっている。

# Cookies + 正当な DNSハイジャック
* 下位のドメイン（subdomain)から上位のドメインのcookieが設定できることを悪用する。
* 広告ページは、cookiesを窃取することが可能である。（もし望めば）
  * nonexistent.example.com は example.com と異なるオリジンである。だが、example.comのcookieにアクセスすることは可能である。
* もし広告ページが悪意のある他者のスクリプトを読み込んだ場合、Cookiesを窃取することが可能である。
* もし広告ページがXSS脆弱性を持っている場合、誰でもexample.comのcookiesを盗むことができる。
  * 攻撃者は nonexistent.example.com/<some-attack-code> にユーザを誘導する。
  * DNSがハイジャックされ、不正なDNSレコードに基づく<some-attack-code> を含んだ広告ページに誘導される
  * これまではオリジンが異なるのにもかかわらず、 nonexistent.example.com は example.com のcookiesにアクセスできた。
  * 現在は、HTTPSにすることで
# Same Origin Policy, Cross-Site Script Inclusion

# リンクを防ぐには
* なぜそんなことをするのか？
  * Search Engine Optimization (SEO) 対策
  * 評価の悪いサイトからのリンクを防ぐ
* どうやってやるか
  * Referrerを使う
# Referrer-Policy HTTP ヘッダ
Refererは、アクセス元のページに関する情報を渡すためのHTTPヘッダの一つである
例：Google検索からの流入の場合、クライアントが送信するHTTPのリクエストヘッダにはReferer: https://www.google.com/の値がつく。サーバ側は、この情報を集めることによって、Webサイトを訪問したクライアントが経由したWebページを知ることができる。

* Referrer-Policy: unsafe-url
  * すべてのURLを送信する
* Referrer-Policy: no-referrer
  * Refererを送らない
* Referrer-Policy: no-referrer-when-downgrade (default)
  * すべてのURLを送信するが、HTTPSからHTTPにダウングレードするときには送信しない。
* Referrer-Policy: origin
  * オリジンを送信する。すべてのURLを送信しない。


# 埋め込みを防ぐことはできるのか
* 第三者が、自分のつくったWebサイトを埋め込むことを防ぎたい！
* なぜそんなことをするのか
  * Clickjacking攻撃を防ぐ
* 例えば、攻撃者が標的をオンラインショッピングサイトで買い物するよう誘導する場合
  * attacker.com がオンラインショッピングサイトをiframeで埋め込む。
    * 埋め込まれたオンラインショッピングサイトが「購入」ボタンを表示する。
    * attacker.comが異なる情報を重ねて表示することで、ボタンの動作を偽装する。その結果、購入に誘導することが出来る。
      * iframeで別のサイトを表示する。そこにダミーのボタン「無料で試す」を表示して「購入」と重ね合わせる。
      * サイト訪問者は「無料で試す」を押したつもりが「購入」ボタンを押すことになる。
  * iframeをCSSで透明に設定することで二つのウィンドウを重ねて偽装することが出来る
# Click Jacking 
* マウスなどの操作のみで重要な処理を実行できるサイトを、iframeとCSSを利用することで誘導し、攻撃する手法である。
* HTMLの仕様を利用した攻撃であり、バグを修正したら防げるタイプの攻撃ではない。
  * 例：Twitterのウェブインテント機能、掲示板への投稿
  ![image](/uploads/0139a858ceba95fbe778acdf4b823f60/image.png)

# DEMO: Click Jacking
* existing_repo/clickjacking-sample-app/
  * 出所：https://auth0.com/blog/preventing-clickjacking-attacks/
  * npm start & node attacker-server.js で起動する
* 攻撃シナリオ：
  * 攻撃者は、Click Jackingにより標的がDVD購入リクエストをするよう誘導する。
  * 攻撃者は、localhost:4000 に標的を誘導する。localhost:4000は、DVD購入ページを埋め込んだサイトである。
  * 標的は南国の休日旅行に当選したと勘違いして、ETのDVD購入リクエストを送る。
  * Dev Tool >network でリクエストを送っていることを確認する。
# Frame busting
* フレーム内でページを開くことを禁止することで、Click Jackingを防ごうとする対策。
  ```
  if(window.top.location != window.location){
    window.top.location = window.location 
    //window がトップにないことがわかった場合、自身をトップにする
  }
  ```
* この対策は、古く、回避手法がある。そのため、別の対策をとる。
# X-Frame-Options HTTP Header
サーバがHTTPhヘッダのX-Frame-Optionsをつかうことで、iframeの動作を制御できる。
* X-Frame-Options: 指定なし（Default)
  * すべてのページをiframeで表示可能
* X-Frame-Options: deny
  * iframe内でのページ表示を拒否する
* X-Frame-Options: sameorigin
  * 同一オリジンの場合のみiframe内でのページを表示可能

attacker.com ⊃ target.comのとき、target.comがX-Frame-Options: sameoriginをレスポンスとして返してきたとき、クライアントはtarget.comを読み込まない。
クライアントは、target.comから送られてきたレスポンスを破棄する。
# X-Frame-Options: sameorigin ができること
* target.comが、target.comを埋め込んでいるothersite.comにアクセスしたら何が起きる？
  * target.com ⊃　othersite.com ⊃ target.com 
  * target.com が読み込んでいるけど、途中に余計なothersite.comがはさまっているとき。
* 近年のブラウザは、埋め込んでいるサイトをチェックしている。
  * ブラウザは最近まで一番上のwindowだけしかチェックしていなかった
* social mediaが広告のiframeを読み込んで、広告が social mediaを読み込んでいるとき
  * 広告は信頼できないソースである

# 自身のWebサイトに対してフォームを送信してくるのを防ぐ方法
* 防ぐ動機： Cross-Site Request Forgery (CSRF)を防ぐ
* 実装方法
  * HTTP リクエストのOrignヘッダを利用する
  * SameSite Cookies

# 自身のWebサイトの画像を他のサイトが埋め込むのを防ぐ方法
* 防ぐ動機： hotlinking(直リン)を防ぎたい、他のサイトがユーザの利用しているアバターを利用することを防ぎたい
* 実装方法: 
  * Hotlinkingに対する対応：Referer ヘッダを検知して、allowlistをつくる
  * アバターに対する対応：SameSite Cookie、予測が難しいURLを使う

# 自身のWebサイトにあるscriptを他のサイトが埋め込むのを防ぐ方法
* 防ぐ動機： 自身で作ったscriptを勝手に利用されないようにする
* 留意すべきこと：scriptはユーザデータを保持しない、埋め込んだサイト（他者のWebサイト）で動作する。
  * 例えば、GoogleのJavaScriptライブラリD3.jsは次のような形で利用できる。`<script src="https://d3js.org/d3.v7.min.js"></script>`
* 実装方法: Referer ヘッダを利用して、allowlistを利用する。
